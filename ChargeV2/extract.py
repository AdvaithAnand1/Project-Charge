import pandas as pd
import datetime, network, store, ctypes, winreg

# TEMPORARY
def extractActiveTime():
    try:
        # Open the Settings key (64-bit view)
        key = winreg.OpenKey(
            winreg.HKEY_LOCAL_MACHINE,
            r"SOFTWARE\Microsoft\WindowsUpdate\UX\Settings",
            0,
            winreg.KEY_READ | winreg.KEY_WOW64_64KEY
        )
        start_hour, _ = winreg.QueryValueEx(key, "ActiveHoursStart")
        end_hour,   _ = winreg.QueryValueEx(key, "ActiveHoursEnd")
        store.store("data", 2, str(start_hour))
        store.store("data", 4, str(end_hour))
        return
    except FileNotFoundError:
        raise RuntimeError("Could not find ActiveHours registry keys.")
    except OSError as e:
        raise RuntimeError(f"Error reading ActiveHours: {e}")

class SYSTEM_POWER_STATUS(ctypes.Structure):
    _fields_ = [
        ("ACLineStatus", ctypes.c_byte),
        ("BatteryFlag", ctypes.c_byte),
        ("BatteryLifePercent", ctypes.c_byte),
        ("Reserved1", ctypes.c_byte),
        ("BatteryLifeTime", ctypes.c_ulong),
        ("BatteryFullLifeTime", ctypes.c_ulong),
    ]

def extractChargeTimeHelper() -> float | None:
    status = SYSTEM_POWER_STATUS()
    if not ctypes.windll.kernel32.GetSystemPowerStatus(ctypes.byref(status)):
        raise ctypes.WinError()
    secs = status.BatteryFullLifeTime
    if secs == 0xFFFFFFFF:
        return None
    return secs / 3600

def extractChargeTime():
    hours = extractChargeTimeHelper()
    if hours is None:
        store.store("data", 10, str(2))
    else:
        store.store("data", 10, str(hours))

def getChargeTime():
    return float(store.getLine("data", 10))

def checkExtracted():
    # get the date that the information was last extracted in and check whether it is within the range we want
    lastdate = datetime.date.fromisoformat(store.getLine("data", 8))
    date = datetime.date.today()
    if ((date - lastdate).days > 7):
        return False
    else:
        return True
def extractAll():
    # extract all of the necessary information from the report generated by windows
    # store a new extraction date
    extractActiveTime()
    extractChargeTime()
    network.save(r"C:\Windows\System32\battery-report.html")
    store.store("data", 8, str(datetime.date.today()))
def getTable(file_path):
    # extract the tables from the html file generated by windows
    history = pd.read_html(file_path)[2]

    # remove the unnecessary information
    history = history[history['STATE'] != 'Suspended'].drop(["CAPACITY REMAINING.1", "STATE"], axis = 1)
    
    # use a map to reassign the charging status to a numerical form and chopping off the rightside characters
    map = {
        "AC": 1,
        "Battery": 0
    }
    history["SOURCE"] = history["SOURCE"].map(map).astype(float)
    history["CAPACITY REMAINING"] = history["CAPACITY REMAINING"].str[:-2].astype(float)

    # convert the date and time to a single number thorugh basic calculation and remap the days of the eweek
    dt_full = pd.to_datetime(history['START TIME'], errors = "coerce")
    history["DATE"] = dt_full.dt.day_name().ffill()
    history['TIME'] = pd.to_datetime(history['START TIME'], format = "mixed")
    map2 = {
        "Sunday": 1,
        "Monday": 2,
        "Tuesday": 3,
        "Wednesday": 4,
        "Thursday": 5,
        "Friday": 6,
        "Saturday": 7
    }
    history = history.drop("START TIME", axis = 1)
    history["DATE"] = history["DATE"].map(map2).astype(float)
    history["TIME"] = history["TIME"].dt.second + history["TIME"].dt.minute * 60 + history["TIME"].dt.hour * 3600
    history["DATE"] /= 7
    history["TIME"] /= 24 * 3600
    history["CAPACITY REMAINING"] /= 100

    # return the normalized table
    return history